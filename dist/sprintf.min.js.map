{"version":3,"sources":["sprintf.js"],"names":["sprintf","key","sprintf_format","sprintf_parse","arguments","vsprintf","fmt","argv","apply","concat","parse_tree","arg","i","k","ph","is_positive","sign","ext_mod","specifier","cursor","tree_length","length","output","type","keys","hasOwnProperty","Error","param_no","modules","padding","precision","substring","re","not_type","test","not_primitive","Function","numeric_arg","isNaN","TypeError","number","parseInt","toString","String","fromCharCode","JSON","stringify","width","parseFloat","toExponential","toFixed","Number","toPrecision","Object","prototype","call","slice","toLowerCase","valueOf","toUpperCase","json","replace","sprintf_cache","match","_fmt","arg_names","text","exec","push","modulo","placeholder","SyntaxError","field_list","replacement_field","field_match","key_access","index_access","embedded_specifier","pad_char","align","format","pad_character","charAt","pad_length","pad","repeat","not_string","not_bool","not_json","create","register_extension","f","exports","window","define"],"mappings":"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","file":"sprintf.min.js","sourcesContent":["/* global window, exports, define */\r\n\r\n!function() {\r\n    'use strict'\r\n\r\n    var re = {\r\n        not_string: /[^s]/,\r\n        not_bool: /[^t]/,\r\n        not_type: /[^T]/,\r\n        not_primitive: /[^v]/,\r\n        number: /[diefg]/,\r\n        numeric_arg: /[bcdiefguxX]/,\r\n        json: /[j]/,\r\n        not_json: /[^j]/,\r\n        text: /^[^\\x25]+/,\r\n        modulo: /^\\x25{2}/,\r\n        specifier: /^[a-zA-Z]$/,\r\n        embedded_specifier: /^[b-gijostTuvxX]$/,\r\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?(?:\\[([^\\]]*)\\])?([a-zA-Z])/,\r\n        key: /^([a-z_][a-z_\\d]*)/i,\r\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\r\n        index_access: /^\\[(\\d+)\\]/,\r\n        sign: /^[\\+\\-]/\r\n    }\r\n\r\n    function sprintf(key) {\r\n        // `arguments` is not an array, but should be fine for this call\r\n        return sprintf_format(sprintf_parse(key), arguments)\r\n    }\r\n\r\n    function vsprintf(fmt, argv) {\r\n        return sprintf.apply(null, [fmt].concat(argv || []))\r\n    }\r\n\r\n    function sprintf_format(parse_tree, argv) {\r\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, is_positive, sign,\r\n            ext_mod, specifier\r\n\r\n        for (i = 0; i < tree_length; i++) {\r\n            if (typeof parse_tree[i] === 'string') {\r\n                output += parse_tree[i]\r\n            }\r\n            else if (typeof parse_tree[i] === 'object') {\r\n                ph = parse_tree[i] // convenience purposes only\r\n                specifier = ph.type\r\n                if (ph.keys) { // keyword argument\r\n                    arg = argv[cursor]\r\n                    for (k = 0; k < ph.keys.length; k++) {\r\n                        if (!arg.hasOwnProperty(ph.keys[k])) {\r\n                            throw new Error(sprintf('[sprintf] property \"%s\" does not exist', ph.keys[k]))\r\n                        }\r\n                        arg = arg[ph.keys[k]]\r\n                    }\r\n                }\r\n                else if (ph.param_no) { // positional argument (explicit)\r\n                    arg = argv[ph.param_no]\r\n                }\r\n                else { // positional argument (implicit)\r\n                    arg = argv[cursor++]\r\n                }\r\n\r\n                ext_mod = sprintf.modules[specifier]\r\n                if ( !ext_mod ) {\r\n                    if (re.not_type.test(specifier) && re.not_primitive.test(specifier) && arg instanceof Function) {\r\n                        arg = arg()\r\n                    }\r\n\r\n                    if (re.numeric_arg.test(specifier) && (typeof arg !== 'number' && isNaN(arg))) {\r\n                        throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\r\n                    }\r\n\r\n                    if (re.number.test(specifier)) {\r\n                        is_positive = arg >= 0\r\n                    }\r\n\r\n                    switch (specifier) {\r\n                        case 'b':\r\n                            arg = parseInt(arg, 10).toString(2)\r\n                            break\r\n                        case 'c':\r\n                            arg = String.fromCharCode(parseInt(arg, 10))\r\n                            break\r\n                        case 'd':\r\n                        case 'i':\r\n                            arg = parseInt(arg, 10)\r\n                            break\r\n                        case 'j':\r\n                            arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\r\n                            break\r\n                        case 'e':\r\n                            arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\r\n                            break\r\n                        case 'f':\r\n                            arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\r\n                            break\r\n                        case 'g':\r\n                            arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\r\n                            break\r\n                        case 'o':\r\n                            arg = (parseInt(arg, 10) >>> 0).toString(8)\r\n                            break\r\n                        case 's':\r\n                            arg = String(arg)\r\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\r\n                            break\r\n                        case 't':\r\n                            arg = String(!!arg)\r\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\r\n                            break\r\n                        case 'T':\r\n                            arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\r\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\r\n                            break\r\n                        case 'u':\r\n                            arg = parseInt(arg, 10) >>> 0\r\n                            break\r\n                        case 'v':\r\n                            arg = arg.valueOf()\r\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\r\n                            break\r\n                        case 'x':\r\n                            arg = (parseInt(arg, 10) >>> 0).toString(16)\r\n                            break\r\n                        case 'X':\r\n                            arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\r\n                            break\r\n                    }\r\n                    if (re.json.test(specifier)) {\r\n                        output += arg\r\n                    }\r\n                    else {\r\n                        if (re.number.test(specifier) && (!is_positive || ph.sign)) {\r\n                            sign = is_positive ? '+' : '-'\r\n                            arg = arg.toString().replace(re.sign, '')\r\n                        }\r\n                        else {\r\n                            sign = ''\r\n                        }\r\n                        output += padding(ph, sign, arg)\r\n                    }\r\n                }\r\n                else { // extension module founded\r\n                    arg = ext_mod(ph, arg)\r\n                    arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\r\n                    output += padding(ph, '', arg)\r\n                }\r\n            }\r\n        }\r\n        return output\r\n    }\r\n\r\n    var sprintf_cache = Object.create(null)\r\n\r\n    function sprintf_parse(fmt) {\r\n        if (sprintf_cache[fmt]) {\r\n            return sprintf_cache[fmt]\r\n        }\r\n\r\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0, specifier\r\n        while (_fmt) {\r\n            if ((match = re.text.exec(_fmt)) !== null) {\r\n                parse_tree.push(match[0])\r\n            }\r\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\r\n                parse_tree.push('%')\r\n            }\r\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\r\n                if (match[2]) {\r\n                    arg_names |= 1\r\n                    var field_list = [], replacement_field = match[2], field_match = []\r\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\r\n                        field_list.push(field_match[1])\r\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\r\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\r\n                                field_list.push(field_match[1])\r\n                            }\r\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\r\n                                field_list.push(field_match[1])\r\n                            }\r\n                            else {\r\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\r\n                    }\r\n                    match[2] = field_list\r\n                }\r\n                else {\r\n                    arg_names |= 2\r\n                }\r\n                if (arg_names === 3) {\r\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\r\n                }\r\n                specifier = match[9]\r\n                if ( !re.embedded_specifier.test(specifier) &&\r\n                     !sprintf.modules[specifier] ) {\r\n                    throw new SyntaxError(sprintf(\"[sprintf] unknown type specifier '%s'\",specifier))\r\n                }\r\n                parse_tree.push(\r\n                    {\r\n                        placeholder: match[0],\r\n                        param_no:    match[1],\r\n                        keys:        match[2],\r\n                        sign:        match[3],\r\n                        pad_char:    match[4],\r\n                        align:       match[5],\r\n                        width:       match[6],\r\n                        precision:   match[7],\r\n                        format:      match[8],\r\n                        type:        specifier\r\n                    }\r\n                )\r\n            }\r\n            else {\r\n                throw new SyntaxError('[sprintf] unexpected placeholder')\r\n            }\r\n            _fmt = _fmt.substring(match[0].length)\r\n        }\r\n        return sprintf_cache[fmt] = parse_tree\r\n    }\r\n\r\n    sprintf.register_extension = function (specifier,f) {\r\n        if ( !re.specifier.test(specifier) ) {\r\n            throw new TypeError(\"[sprintf] invalid specifier\")\r\n        }\r\n        sprintf.modules[specifier] = f\r\n    }\r\n\r\n    sprintf.modules = Object.create(null)\r\n\r\n    function padding(ph, sign, arg) {\r\n        var pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\r\n        var pad_length = ph.width - (sign + arg).length\r\n        var pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\r\n        return ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\r\n    }\r\n\r\n    /**\r\n     * export to either browser or node.js\r\n     */\r\n    /* eslint-disable quote-props */\r\n    if (typeof exports !== 'undefined') {\r\n        exports['sprintf'] = sprintf\r\n        exports['vsprintf'] = vsprintf\r\n    }\r\n    if (typeof window !== 'undefined') {\r\n        window['sprintf'] = sprintf\r\n        window['vsprintf'] = vsprintf\r\n\r\n        if (typeof define === 'function' && define['amd']) {\r\n            define(function() {\r\n                return {\r\n                    'sprintf': sprintf,\r\n                    'vsprintf': vsprintf\r\n                }\r\n            })\r\n        }\r\n    }\r\n    /* eslint-enable quote-props */\r\n}()\r\n"]}